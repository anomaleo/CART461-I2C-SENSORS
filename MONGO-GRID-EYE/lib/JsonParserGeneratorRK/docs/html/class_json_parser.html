<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JsonParserGeneratorRK: JsonParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JsonParserGeneratorRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">JsonParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>API to the <a class="el" href="class_json_parser.html" title="API to the JsonParser. ">JsonParser</a>.  
 <a href="class_json_parser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_json_parser_generator_r_k_8h_source.html">JsonParserGeneratorRK.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for JsonParser:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_json_parser.png" usemap="#JsonParser_map" alt=""/>
  <map id="JsonParser_map" name="JsonParser_map">
<area href="class_json_buffer.html" title="Base class for managing a static or dynamic buffer, used by both JsonParser and JsonWriter. " alt="JsonBuffer" shape="rect" coords="0,0,310,24"/>
<area href="class_json_parser_static.html" title="Creates a JsonParser with a static buffer. " alt="JsonParserStatic&lt; BUFFER_SIZE, MAX_TOKENS &gt;" shape="rect" coords="0,112,310,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af21abdfb0ceac731e44d897a0285f5d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#af21abdfb0ceac731e44d897a0285f5d4">JsonParser</a> ()</td></tr>
<tr class="memdesc:af21abdfb0ceac731e44d897a0285f5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a parser object.  <a href="#af21abdfb0ceac731e44d897a0285f5d4">More...</a><br /></td></tr>
<tr class="separator:af21abdfb0ceac731e44d897a0285f5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0393b54c37f9ff30b6bb59f0ba92ce"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a7c0393b54c37f9ff30b6bb59f0ba92ce">~JsonParser</a> ()</td></tr>
<tr class="memdesc:a7c0393b54c37f9ff30b6bb59f0ba92ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a parser object.  <a href="#a7c0393b54c37f9ff30b6bb59f0ba92ce">More...</a><br /></td></tr>
<tr class="separator:a7c0393b54c37f9ff30b6bb59f0ba92ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f8fa82e72240ce4ad6e6ca25700b6"><td class="memItemLeft" align="right" valign="top"><a id="a394f8fa82e72240ce4ad6e6ca25700b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a394f8fa82e72240ce4ad6e6ca25700b6">JsonParser</a> (char *<a class="el" href="class_json_buffer.html#aaee27fe51d12d68bd6031df3bc78b6b5">buffer</a>, size_t <a class="el" href="class_json_buffer.html#af06130f43f71623ea6afe049c846e52b">bufferLen</a>, <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *<a class="el" href="class_json_parser.html#af2a9bba1dc92b0c38d0cab6fdad76216">tokens</a>, size_t <a class="el" href="class_json_parser.html#a0dfa97de05bac37c5be2e1ee9747b8a2">maxTokens</a>)</td></tr>
<tr class="memdesc:a394f8fa82e72240ce4ad6e6ca25700b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static buffers constructor. <br /></td></tr>
<tr class="separator:a394f8fa82e72240ce4ad6e6ca25700b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1731e3265d6b2f89587638dcd6d7ff34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a1731e3265d6b2f89587638dcd6d7ff34">allocateTokens</a> (size_t <a class="el" href="class_json_parser.html#a0dfa97de05bac37c5be2e1ee9747b8a2">maxTokens</a>)</td></tr>
<tr class="memdesc:a1731e3265d6b2f89587638dcd6d7ff34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preallocates a specific number of tokens.  <a href="#a1731e3265d6b2f89587638dcd6d7ff34">More...</a><br /></td></tr>
<tr class="separator:a1731e3265d6b2f89587638dcd6d7ff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad528213e8600cbad4d85910b62fc033a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#ad528213e8600cbad4d85910b62fc033a">parse</a> ()</td></tr>
<tr class="memdesc:ad528213e8600cbad4d85910b62fc033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the data you have added using <a class="el" href="class_json_buffer.html#a760cb5be42ed2d2ca9306b1109e76af3" title="Add a string to the end of the buffer. ">addData()</a> or <a class="el" href="class_json_buffer.html#a61bf30ac6e1bd460f1e809d02a7d5ba4" title="Add a c-string to the end of the buffer. ">addString()</a>.  <a href="#ad528213e8600cbad4d85910b62fc033a">More...</a><br /></td></tr>
<tr class="separator:ad528213e8600cbad4d85910b62fc033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f639337cff7b364edb05c01f098786"><td class="memItemLeft" align="right" valign="top"><a id="a27f639337cff7b364edb05c01f098786"></a>
<a class="el" href="class_json_reference.html">JsonReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a27f639337cff7b364edb05c01f098786">getReference</a> () const</td></tr>
<tr class="memdesc:a27f639337cff7b364edb05c01f098786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_json_reference.html" title="This class provides a fluent-style API for easily traversing a tree of JSON objects to find a value...">JsonReference</a> object. This is used for fluent-style access to the data. <br /></td></tr>
<tr class="separator:a27f639337cff7b364edb05c01f098786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e694318a7c823d4cca3a5be49907df7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a4e694318a7c823d4cca3a5be49907df7">getOuterObject</a> () const</td></tr>
<tr class="memdesc:a4e694318a7c823d4cca3a5be49907df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the outer JSON object token.  <a href="#a4e694318a7c823d4cca3a5be49907df7">More...</a><br /></td></tr>
<tr class="separator:a4e694318a7c823d4cca3a5be49907df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ffa7e1c4d2fbc2524533d65c31b605"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a91ffa7e1c4d2fbc2524533d65c31b605">getOuterArray</a> () const</td></tr>
<tr class="memdesc:a91ffa7e1c4d2fbc2524533d65c31b605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the outer JSON array token.  <a href="#a91ffa7e1c4d2fbc2524533d65c31b605">More...</a><br /></td></tr>
<tr class="separator:a91ffa7e1c4d2fbc2524533d65c31b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c28b01c0e1fc3c7677e07e1739ea288"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a3c28b01c0e1fc3c7677e07e1739ea288">getOuterToken</a> () const</td></tr>
<tr class="memdesc:a3c28b01c0e1fc3c7677e07e1739ea288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the outer JSON object or array token.  <a href="#a3c28b01c0e1fc3c7677e07e1739ea288">More...</a><br /></td></tr>
<tr class="separator:a3c28b01c0e1fc3c7677e07e1739ea288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb46af21c13fa2396e065543bd8db265"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#aeb46af21c13fa2396e065543bd8db265">getArraySize</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *arrayContainer) const</td></tr>
<tr class="memdesc:aeb46af21c13fa2396e065543bd8db265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a token for an JSON array in arrayContainer, gets the number of elements in the array.  <a href="#aeb46af21c13fa2396e065543bd8db265">More...</a><br /></td></tr>
<tr class="separator:aeb46af21c13fa2396e065543bd8db265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13abcdcb2341f65ac358bb4d81007d06"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a13abcdcb2341f65ac358bb4d81007d06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06">getValueByKey</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *container, const char *name, T &amp;result) const</td></tr>
<tr class="memdesc:a13abcdcb2341f65ac358bb4d81007d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an object token in container, gets the value with the specified key name.  <a href="#a13abcdcb2341f65ac358bb4d81007d06">More...</a><br /></td></tr>
<tr class="separator:a13abcdcb2341f65ac358bb4d81007d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38858994342cd2735b716b117bf8afdf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a38858994342cd2735b716b117bf8afdf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a38858994342cd2735b716b117bf8afdf">getOuterValueByKey</a> (const char *name, T &amp;result) const</td></tr>
<tr class="memdesc:a38858994342cd2735b716b117bf8afdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value with the specified key name out of the outer object.  <a href="#a38858994342cd2735b716b117bf8afdf">More...</a><br /></td></tr>
<tr class="separator:a38858994342cd2735b716b117bf8afdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5759f53499dcb4418e07e9c5e1a42442"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5759f53499dcb4418e07e9c5e1a42442"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a5759f53499dcb4418e07e9c5e1a42442">getKeyValueByIndex</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *container, size_t index, <a class="el" href="class_string.html">String</a> &amp;key, T &amp;result) const</td></tr>
<tr class="memdesc:a5759f53499dcb4418e07e9c5e1a42442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the key/value pair of an object by index.  <a href="#a5759f53499dcb4418e07e9c5e1a42442">More...</a><br /></td></tr>
<tr class="separator:a5759f53499dcb4418e07e9c5e1a42442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4718893bc6350e129a9acbf6cb5a47ad"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4718893bc6350e129a9acbf6cb5a47ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a4718893bc6350e129a9acbf6cb5a47ad">getOuterKeyValueByIndex</a> (size_t index, <a class="el" href="class_string.html">String</a> &amp;key, T &amp;result) const</td></tr>
<tr class="memdesc:a4718893bc6350e129a9acbf6cb5a47ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the key/value pair of the outer object by index (0 = first, 1 = second, ...)  <a href="#a4718893bc6350e129a9acbf6cb5a47ad">More...</a><br /></td></tr>
<tr class="separator:a4718893bc6350e129a9acbf6cb5a47ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bd8a6ebb0d9b246b876653e792368f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a53bd8a6ebb0d9b246b876653e792368f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f">getValueByIndex</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *arrayContainer, size_t index, T &amp;result) const</td></tr>
<tr class="memdesc:a53bd8a6ebb0d9b246b876653e792368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array token in arrayContainer, gets the value with the specified index.  <a href="#a53bd8a6ebb0d9b246b876653e792368f">More...</a><br /></td></tr>
<tr class="separator:a53bd8a6ebb0d9b246b876653e792368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f4a3a65b5cc9cd19b129c410aa78e0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af1f4a3a65b5cc9cd19b129c410aa78e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_json_parser.html#af1f4a3a65b5cc9cd19b129c410aa78e0">getValueByColRow</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *arrayContainer, size_t col, size_t row, T &amp;result) const</td></tr>
<tr class="memdesc:af1f4a3a65b5cc9cd19b129c410aa78e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values.  <a href="#af1f4a3a65b5cc9cd19b129c410aa78e0">More...</a><br /></td></tr>
<tr class="separator:af1f4a3a65b5cc9cd19b129c410aa78e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d613e94d0d6beafe908159f86bc067"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a39d613e94d0d6beafe908159f86bc067">getValueTokenByKey</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *container, const char *key, const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;value) const</td></tr>
<tr class="memdesc:a39d613e94d0d6beafe908159f86bc067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an object token in container, gets the token value with the specified key name.  <a href="#a39d613e94d0d6beafe908159f86bc067">More...</a><br /></td></tr>
<tr class="separator:a39d613e94d0d6beafe908159f86bc067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680846b3e3e3e1d40c27bbb71e080048"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a680846b3e3e3e1d40c27bbb71e080048">getValueTokenByIndex</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *container, size_t desiredIndex, const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;value) const</td></tr>
<tr class="memdesc:a680846b3e3e3e1d40c27bbb71e080048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array token in container, gets the token value with the specified index.  <a href="#a680846b3e3e3e1d40c27bbb71e080048">More...</a><br /></td></tr>
<tr class="separator:a680846b3e3e3e1d40c27bbb71e080048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc494206dd45eba5959ffc2df444a21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a4fc494206dd45eba5959ffc2df444a21">getValueTokenByColRow</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *container, size_t col, size_t row, const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;value) const</td></tr>
<tr class="memdesc:a4fc494206dd45eba5959ffc2df444a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values.  <a href="#a4fc494206dd45eba5959ffc2df444a21">More...</a><br /></td></tr>
<tr class="separator:a4fc494206dd45eba5959ffc2df444a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588d9c4fcfe9179db67ca42f5ba5229d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a588d9c4fcfe9179db67ca42f5ba5229d">getTokenByIndex</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *container, size_t desiredIndex) const</td></tr>
<tr class="memdesc:a588d9c4fcfe9179db67ca42f5ba5229d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a containing object, finds the nth token in the object. Internal use only.  <a href="#a588d9c4fcfe9179db67ca42f5ba5229d">More...</a><br /></td></tr>
<tr class="separator:a588d9c4fcfe9179db67ca42f5ba5229d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946929ab0c54eed7e7c8697e9304d553"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a946929ab0c54eed7e7c8697e9304d553">getKeyValueTokenByIndex</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *container, const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;key, const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;value, size_t index) const</td></tr>
<tr class="memdesc:a946929ab0c54eed7e7c8697e9304d553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a JSON object in container, gets the key/value pair specified by index. Internal use only.  <a href="#a946929ab0c54eed7e7c8697e9304d553">More...</a><br /></td></tr>
<tr class="separator:a946929ab0c54eed7e7c8697e9304d553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182ab93b3639f0a99f37f9101eb48361"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a182ab93b3639f0a99f37f9101eb48361">skipObject</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *container, const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;obj) const</td></tr>
<tr class="memdesc:a182ab93b3639f0a99f37f9101eb48361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to skip over the token in obj.  <a href="#a182ab93b3639f0a99f37f9101eb48361">More...</a><br /></td></tr>
<tr class="separator:a182ab93b3639f0a99f37f9101eb48361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f8a2873dd3a2935cf0a22133a5378f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#ab7f8a2873dd3a2935cf0a22133a5378f">copyTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, char *dst, size_t dstLen) const</td></tr>
<tr class="memdesc:ab7f8a2873dd3a2935cf0a22133a5378f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of the token into a buffer, making it a null-terminated cstring.  <a href="#ab7f8a2873dd3a2935cf0a22133a5378f">More...</a><br /></td></tr>
<tr class="separator:ab7f8a2873dd3a2935cf0a22133a5378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9e5c2453307a99a54fcf26fbd68dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a5f9e5c2453307a99a54fcf26fbd68dd4">getTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, bool &amp;result) const</td></tr>
<tr class="memdesc:a5f9e5c2453307a99a54fcf26fbd68dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a bool (boolean) value.  <a href="#a5f9e5c2453307a99a54fcf26fbd68dd4">More...</a><br /></td></tr>
<tr class="separator:a5f9e5c2453307a99a54fcf26fbd68dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875e5b4b01c9cd597e09b13e59fe6252"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a875e5b4b01c9cd597e09b13e59fe6252">getTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, int &amp;result) const</td></tr>
<tr class="memdesc:a875e5b4b01c9cd597e09b13e59fe6252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an integer value.  <a href="#a875e5b4b01c9cd597e09b13e59fe6252">More...</a><br /></td></tr>
<tr class="separator:a875e5b4b01c9cd597e09b13e59fe6252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6289b63a2281dc516e4a81aa3660ac7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#ad6289b63a2281dc516e4a81aa3660ac7">getTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, unsigned long &amp;result) const</td></tr>
<tr class="memdesc:ad6289b63a2281dc516e4a81aa3660ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an unsigned long value.  <a href="#ad6289b63a2281dc516e4a81aa3660ac7">More...</a><br /></td></tr>
<tr class="separator:ad6289b63a2281dc516e4a81aa3660ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a6ad66b9697ceb6b789b4c9abaa3ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a37a6ad66b9697ceb6b789b4c9abaa3ab">getTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, float &amp;result) const</td></tr>
<tr class="memdesc:a37a6ad66b9697ceb6b789b4c9abaa3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a float (single precision floating point) value.  <a href="#a37a6ad66b9697ceb6b789b4c9abaa3ab">More...</a><br /></td></tr>
<tr class="separator:a37a6ad66b9697ceb6b789b4c9abaa3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af378b1400c3f091ae6ba67dc588ca863"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#af378b1400c3f091ae6ba67dc588ca863">getTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, double &amp;result) const</td></tr>
<tr class="memdesc:af378b1400c3f091ae6ba67dc588ca863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a double (double precision floating point) value.  <a href="#af378b1400c3f091ae6ba67dc588ca863">More...</a><br /></td></tr>
<tr class="separator:af378b1400c3f091ae6ba67dc588ca863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cff567586e80ba63d39324e5929672"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a44cff567586e80ba63d39324e5929672">getTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, <a class="el" href="class_string.html">String</a> &amp;result) const</td></tr>
<tr class="memdesc:a44cff567586e80ba63d39324e5929672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a> value into a Wiring <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a> object.  <a href="#a44cff567586e80ba63d39324e5929672">More...</a><br /></td></tr>
<tr class="separator:a44cff567586e80ba63d39324e5929672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c0b33d4ddeae1e0d605e166a2a772c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#aa5c0b33d4ddeae1e0d605e166a2a772c">getTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, char *str, size_t &amp;strLen) const</td></tr>
<tr class="memdesc:aa5c0b33d4ddeae1e0d605e166a2a772c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string as a c-string into the specified buffer.  <a href="#aa5c0b33d4ddeae1e0d605e166a2a772c">More...</a><br /></td></tr>
<tr class="separator:aa5c0b33d4ddeae1e0d605e166a2a772c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6942f718b6b73d2ff1611f55aec8569c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a6942f718b6b73d2ff1611f55aec8569c">getTokenValue</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, <a class="el" href="class_json_parser_string.html">JsonParserString</a> &amp;str) const</td></tr>
<tr class="memdesc:a6942f718b6b73d2ff1611f55aec8569c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string as a <a class="el" href="class_json_parser_string.html" title="Class used internally for writing to strings. ">JsonParserString</a> object.  <a href="#a6942f718b6b73d2ff1611f55aec8569c">More...</a><br /></td></tr>
<tr class="separator:a6942f718b6b73d2ff1611f55aec8569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334ccfff663a5d3155a799049896d55c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a334ccfff663a5d3155a799049896d55c">getTokenJsonString</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, <a class="el" href="class_string.html">String</a> &amp;result) const</td></tr>
<tr class="memdesc:a334ccfff663a5d3155a799049896d55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a token (object, array, string, or primitive) back into JSON in a Wiring <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a>.  <a href="#a334ccfff663a5d3155a799049896d55c">More...</a><br /></td></tr>
<tr class="separator:a334ccfff663a5d3155a799049896d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af235693afede52de81794e3773e5cff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#af235693afede52de81794e3773e5cff4">getTokenJsonString</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, char *str, size_t &amp;strLen) const</td></tr>
<tr class="memdesc:af235693afede52de81794e3773e5cff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a token (object, array, string, or primitive) back into JSON in a buffer.  <a href="#af235693afede52de81794e3773e5cff4">More...</a><br /></td></tr>
<tr class="separator:af235693afede52de81794e3773e5cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d9fc64d49d057dd2b7b3ea63a7d8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a4c6d9fc64d49d057dd2b7b3ea63a7d8c">getTokenJsonString</a> (const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *token, <a class="el" href="class_json_parser_string.html">JsonParserString</a> &amp;str) const</td></tr>
<tr class="memdesc:a4c6d9fc64d49d057dd2b7b3ea63a7d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a token as a JSON string.  <a href="#a4c6d9fc64d49d057dd2b7b3ea63a7d8c">More...</a><br /></td></tr>
<tr class="separator:a4c6d9fc64d49d057dd2b7b3ea63a7d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdeae1e2cf1b45cde47ca8a8f9a84c9"><td class="memItemLeft" align="right" valign="top"><a id="a1cdeae1e2cf1b45cde47ca8a8f9a84c9"></a>
<a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a1cdeae1e2cf1b45cde47ca8a8f9a84c9">getTokens</a> ()</td></tr>
<tr class="memdesc:a1cdeae1e2cf1b45cde47ca8a8f9a84c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally in the test suite for printing the token list. <br /></td></tr>
<tr class="separator:a1cdeae1e2cf1b45cde47ca8a8f9a84c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0503af76c2bc9b8d2231dddb8b1cb3"><td class="memItemLeft" align="right" valign="top"><a id="a8e0503af76c2bc9b8d2231dddb8b1cb3"></a>
<a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a8e0503af76c2bc9b8d2231dddb8b1cb3">getTokensEnd</a> ()</td></tr>
<tr class="memdesc:a8e0503af76c2bc9b8d2231dddb8b1cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally in the test suite for printing the token list. <br /></td></tr>
<tr class="separator:a8e0503af76c2bc9b8d2231dddb8b1cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e91342fbbb72d6fb304dd2f2e7f505"><td class="memItemLeft" align="right" valign="top"><a id="a39e91342fbbb72d6fb304dd2f2e7f505"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a39e91342fbbb72d6fb304dd2f2e7f505">getMaxTokens</a> () const</td></tr>
<tr class="memdesc:a39e91342fbbb72d6fb304dd2f2e7f505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally in the test suite for printing the token list. <br /></td></tr>
<tr class="separator:a39e91342fbbb72d6fb304dd2f2e7f505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_json_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_json_buffer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_json_buffer.html">JsonBuffer</a></td></tr>
<tr class="memitem:a7198fe2dc430c6ebbc2374698c86f932 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a7198fe2dc430c6ebbc2374698c86f932"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a7198fe2dc430c6ebbc2374698c86f932">JsonBuffer</a> ()</td></tr>
<tr class="memdesc:a7198fe2dc430c6ebbc2374698c86f932 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_json_buffer.html" title="Base class for managing a static or dynamic buffer, used by both JsonParser and JsonWriter. ">JsonBuffer</a> object with no external buffer specified. <br /></td></tr>
<tr class="separator:a7198fe2dc430c6ebbc2374698c86f932 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634ecf551d2d738b7a80b513e2c5a468 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a634ecf551d2d738b7a80b513e2c5a468"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a634ecf551d2d738b7a80b513e2c5a468">~JsonBuffer</a> ()</td></tr>
<tr class="memdesc:a634ecf551d2d738b7a80b513e2c5a468 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Destroying the object does not delete any underlying buffer! <br /></td></tr>
<tr class="separator:a634ecf551d2d738b7a80b513e2c5a468 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645819ad48ee172c01a482bef9c1f765 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a645819ad48ee172c01a482bef9c1f765">JsonBuffer</a> (char *<a class="el" href="class_json_buffer.html#aaee27fe51d12d68bd6031df3bc78b6b5">buffer</a>, size_t <a class="el" href="class_json_buffer.html#af06130f43f71623ea6afe049c846e52b">bufferLen</a>)</td></tr>
<tr class="memdesc:a645819ad48ee172c01a482bef9c1f765 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_json_buffer.html" title="Base class for managing a static or dynamic buffer, used by both JsonParser and JsonWriter. ">JsonBuffer</a> with an external buffer of a given size.  <a href="class_json_buffer.html#a645819ad48ee172c01a482bef9c1f765">More...</a><br /></td></tr>
<tr class="separator:a645819ad48ee172c01a482bef9c1f765 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6721ab2b50d9b0bfc64d51c84c295230 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a6721ab2b50d9b0bfc64d51c84c295230">setBuffer</a> (char *<a class="el" href="class_json_buffer.html#aaee27fe51d12d68bd6031df3bc78b6b5">buffer</a>, size_t <a class="el" href="class_json_buffer.html#af06130f43f71623ea6afe049c846e52b">bufferLen</a>)</td></tr>
<tr class="memdesc:a6721ab2b50d9b0bfc64d51c84c295230 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the buffers to the specified buffer and length.  <a href="class_json_buffer.html#a6721ab2b50d9b0bfc64d51c84c295230">More...</a><br /></td></tr>
<tr class="separator:a6721ab2b50d9b0bfc64d51c84c295230 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb9d0cae3ef9a9ac56b8580bc70fe2e inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a1eb9d0cae3ef9a9ac56b8580bc70fe2e">allocate</a> (size_t len)</td></tr>
<tr class="memdesc:a1eb9d0cae3ef9a9ac56b8580bc70fe2e inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the buffer using malloc/realloc.  <a href="class_json_buffer.html#a1eb9d0cae3ef9a9ac56b8580bc70fe2e">More...</a><br /></td></tr>
<tr class="separator:a1eb9d0cae3ef9a9ac56b8580bc70fe2e inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bf30ac6e1bd460f1e809d02a7d5ba4 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a61bf30ac6e1bd460f1e809d02a7d5ba4">addString</a> (const char *data)</td></tr>
<tr class="memdesc:a61bf30ac6e1bd460f1e809d02a7d5ba4 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a c-string to the end of the buffer.  <a href="class_json_buffer.html#a61bf30ac6e1bd460f1e809d02a7d5ba4">More...</a><br /></td></tr>
<tr class="separator:a61bf30ac6e1bd460f1e809d02a7d5ba4 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760cb5be42ed2d2ca9306b1109e76af3 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a760cb5be42ed2d2ca9306b1109e76af3">addData</a> (const char *data, size_t dataLen)</td></tr>
<tr class="memdesc:a760cb5be42ed2d2ca9306b1109e76af3 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a string to the end of the buffer.  <a href="class_json_buffer.html#a760cb5be42ed2d2ca9306b1109e76af3">More...</a><br /></td></tr>
<tr class="separator:a760cb5be42ed2d2ca9306b1109e76af3 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ca5014e0275487273f94c6b9223acf inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#af8ca5014e0275487273f94c6b9223acf">getBuffer</a> () const</td></tr>
<tr class="memdesc:af8ca5014e0275487273f94c6b9223acf inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the internal buffer.  <a href="class_json_buffer.html#af8ca5014e0275487273f94c6b9223acf">More...</a><br /></td></tr>
<tr class="separator:af8ca5014e0275487273f94c6b9223acf inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedc049fc02ef5bad2b3f8e7a1ba17b6 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top"><a id="adedc049fc02ef5bad2b3f8e7a1ba17b6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#adedc049fc02ef5bad2b3f8e7a1ba17b6">getOffset</a> () const</td></tr>
<tr class="memdesc:adedc049fc02ef5bad2b3f8e7a1ba17b6 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current offset for writing. <br /></td></tr>
<tr class="separator:adedc049fc02ef5bad2b3f8e7a1ba17b6 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0043413c56e23d83f3b4dbe508a35315 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a0043413c56e23d83f3b4dbe508a35315"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a0043413c56e23d83f3b4dbe508a35315">setOffset</a> (size_t <a class="el" href="class_json_buffer.html#aeb1ab3291108f351834f2e8c6784538c">offset</a>)</td></tr>
<tr class="memdesc:a0043413c56e23d83f3b4dbe508a35315 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">swets the current offset for writing <br /></td></tr>
<tr class="separator:a0043413c56e23d83f3b4dbe508a35315 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486352be5658e94b9b9bd13563801e68 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a486352be5658e94b9b9bd13563801e68">getBufferLen</a> () const</td></tr>
<tr class="memdesc:a486352be5658e94b9b9bd13563801e68 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current length of the buffer.  <a href="class_json_buffer.html#a486352be5658e94b9b9bd13563801e68">More...</a><br /></td></tr>
<tr class="separator:a486352be5658e94b9b9bd13563801e68 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70969847d857815a9ded6450378e0e53 inherit pub_methods_class_json_buffer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a70969847d857815a9ded6450378e0e53">clear</a> ()</td></tr>
<tr class="memdesc:a70969847d857815a9ded6450378e0e53 inherit pub_methods_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the current buffer for writing.  <a href="class_json_buffer.html#a70969847d857815a9ded6450378e0e53">More...</a><br /></td></tr>
<tr class="separator:a70969847d857815a9ded6450378e0e53 inherit pub_methods_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a498dcdec7949c88dfc454d052e25ff69"><td class="memItemLeft" align="right" valign="top"><a id="a498dcdec7949c88dfc454d052e25ff69"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a498dcdec7949c88dfc454d052e25ff69">appendUtf8</a> (uint16_t unicode, <a class="el" href="class_json_parser_string.html">JsonParserString</a> &amp;str)</td></tr>
<tr class="memdesc:a498dcdec7949c88dfc454d052e25ff69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Unicode UTF-16 code point, converts it to UTF-8 and appends it to str. <br /></td></tr>
<tr class="separator:a498dcdec7949c88dfc454d052e25ff69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af2a9bba1dc92b0c38d0cab6fdad76216"><td class="memItemLeft" align="right" valign="top"><a id="af2a9bba1dc92b0c38d0cab6fdad76216"></a>
<a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#af2a9bba1dc92b0c38d0cab6fdad76216">tokens</a></td></tr>
<tr class="memdesc:af2a9bba1dc92b0c38d0cab6fdad76216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of tokens after parsing. <br /></td></tr>
<tr class="separator:af2a9bba1dc92b0c38d0cab6fdad76216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8c13ce885f8bc7470248d0dc56f157"><td class="memItemLeft" align="right" valign="top"><a id="a6b8c13ce885f8bc7470248d0dc56f157"></a>
<a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a6b8c13ce885f8bc7470248d0dc56f157">tokensEnd</a></td></tr>
<tr class="memdesc:a6b8c13ce885f8bc7470248d0dc56f157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer into tokens, points after last used token. <br /></td></tr>
<tr class="separator:a6b8c13ce885f8bc7470248d0dc56f157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfa97de05bac37c5be2e1ee9747b8a2"><td class="memItemLeft" align="right" valign="top"><a id="a0dfa97de05bac37c5be2e1ee9747b8a2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#a0dfa97de05bac37c5be2e1ee9747b8a2">maxTokens</a></td></tr>
<tr class="memdesc:a0dfa97de05bac37c5be2e1ee9747b8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of tokens that can be stored in tokens. <br /></td></tr>
<tr class="separator:a0dfa97de05bac37c5be2e1ee9747b8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d3dc7a971bd6c8e578518ba6c874f9"><td class="memItemLeft" align="right" valign="top"><a id="ad8d3dc7a971bd6c8e578518ba6c874f9"></a>
<a class="el" href="struct_json_parser_generator_r_k_1_1jsmn__parser.html">JsonParserGeneratorRK::jsmn_parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_parser.html#ad8d3dc7a971bd6c8e578518ba6c874f9">parser</a></td></tr>
<tr class="memdesc:ad8d3dc7a971bd6c8e578518ba6c874f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The JSMN parser object. <br /></td></tr>
<tr class="separator:ad8d3dc7a971bd6c8e578518ba6c874f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_json_buffer"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_json_buffer')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_json_buffer.html">JsonBuffer</a></td></tr>
<tr class="memitem:aaee27fe51d12d68bd6031df3bc78b6b5 inherit pro_attribs_class_json_buffer"><td class="memItemLeft" align="right" valign="top"><a id="aaee27fe51d12d68bd6031df3bc78b6b5"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#aaee27fe51d12d68bd6031df3bc78b6b5">buffer</a></td></tr>
<tr class="memdesc:aaee27fe51d12d68bd6031df3bc78b6b5 inherit pro_attribs_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer to to read from or write to. This is not null-terminated. <br /></td></tr>
<tr class="separator:aaee27fe51d12d68bd6031df3bc78b6b5 inherit pro_attribs_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06130f43f71623ea6afe049c846e52b inherit pro_attribs_class_json_buffer"><td class="memItemLeft" align="right" valign="top"><a id="af06130f43f71623ea6afe049c846e52b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#af06130f43f71623ea6afe049c846e52b">bufferLen</a></td></tr>
<tr class="memdesc:af06130f43f71623ea6afe049c846e52b inherit pro_attribs_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of the buffer in bytes,. <br /></td></tr>
<tr class="separator:af06130f43f71623ea6afe049c846e52b inherit pro_attribs_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1ab3291108f351834f2e8c6784538c inherit pro_attribs_class_json_buffer"><td class="memItemLeft" align="right" valign="top"><a id="aeb1ab3291108f351834f2e8c6784538c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#aeb1ab3291108f351834f2e8c6784538c">offset</a></td></tr>
<tr class="memdesc:aeb1ab3291108f351834f2e8c6784538c inherit pro_attribs_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">The read or write offset. <br /></td></tr>
<tr class="separator:aeb1ab3291108f351834f2e8c6784538c inherit pro_attribs_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729845e25c624d1dcb1da9712afbcdf7 inherit pro_attribs_class_json_buffer"><td class="memItemLeft" align="right" valign="top"><a id="a729845e25c624d1dcb1da9712afbcdf7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_json_buffer.html#a729845e25c624d1dcb1da9712afbcdf7">staticBuffers</a></td></tr>
<tr class="memdesc:a729845e25c624d1dcb1da9712afbcdf7 inherit pro_attribs_class_json_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the buffers were passed in and should not freed or reallocated. <br /></td></tr>
<tr class="separator:a729845e25c624d1dcb1da9712afbcdf7 inherit pro_attribs_class_json_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a26df0cdb3650a4a46921ba1793ecfd03"><td class="memItemLeft" align="right" valign="top"><a id="a26df0cdb3650a4a46921ba1793ecfd03"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>JsonModifier</b></td></tr>
<tr class="separator:a26df0cdb3650a4a46921ba1793ecfd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>API to the <a class="el" href="class_json_parser.html" title="API to the JsonParser. ">JsonParser</a>. </p>
<p>This is a memory-efficient JSON parser based on jsmn. It only keeps one copy of the data in raw format and an array of tokens. You make calls to read values out. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af21abdfb0ceac731e44d897a0285f5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21abdfb0ceac731e44d897a0285f5d4">&#9670;&nbsp;</a></span>JsonParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JsonParser::JsonParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a parser object. </p>
<p>This version dynamically allocates the buffer and token storage. If you want to minimize memory allocations you can pass in a static buffer and array of tokens to use instead. </p>

</div>
</div>
<a id="a7c0393b54c37f9ff30b6bb59f0ba92ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0393b54c37f9ff30b6bb59f0ba92ce">&#9670;&nbsp;</a></span>~JsonParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JsonParser::~JsonParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a parser object. </p>
<p>If the buffer was allocated dynamically it will be deleted. If you passed in a static buffer the static buffer is not deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1731e3265d6b2f89587638dcd6d7ff34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1731e3265d6b2f89587638dcd6d7ff34">&#9670;&nbsp;</a></span>allocateTokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::allocateTokens </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxTokens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preallocates a specific number of tokens. </p>
<p>Optional: You should set this larger than the expected number of tokens for efficiency, but if you are not using the static allocator it will resize the token storage space if it's too small. </p>

</div>
</div>
<a id="ab7f8a2873dd3a2935cf0a22133a5378f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f8a2873dd3a2935cf0a22133a5378f">&#9670;&nbsp;</a></span>copyTokenValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JsonParser::copyTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the value of the token into a buffer, making it a null-terminated cstring. </p>
<p>If the string is longer than dstLen - 1 bytes, it will be truncated and the result will still be a valid cstring.</p>
<p>This is used internally because the token data is not null-terminated, and doing things like sscanf or strtoul on it can read past the end of the buffer. This assures that only null-terminated data is passed to these functions. </p>

</div>
</div>
<a id="aeb46af21c13fa2396e065543bd8db265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb46af21c13fa2396e065543bd8db265">&#9670;&nbsp;</a></span>getArraySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t JsonParser::getArraySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>arrayContainer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a token for an JSON array in arrayContainer, gets the number of elements in the array. </p>
<p>0 = no elements, 1 = one element, ...</p>
<p>The index values for <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a>, etc. are 0-based, so the last index you pass in is less than <a class="el" href="class_json_parser.html#aeb46af21c13fa2396e065543bd8db265" title="Given a token for an JSON array in arrayContainer, gets the number of elements in the array...">getArraySize()</a>. </p>

</div>
</div>
<a id="a5759f53499dcb4418e07e9c5e1a42442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5759f53499dcb4418e07e9c5e1a42442">&#9670;&nbsp;</a></span>getKeyValueByIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getKeyValueByIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the key/value pair of an object by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The object to look in (see getOuterKeyValueByIndex if you want to the outermost object you parsed)</td></tr>
    <tr><td class="paramname">index</td><td>0 = first, 1 = second, ...</td></tr>
    <tr><td class="paramname">key</td><td>Filled in with the name of the key</td></tr>
    <tr><td class="paramname">result</td><td>Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a>, or (char *, size_t&amp;).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the call succeeded or false if it failed.</dd></dl>
<p>Normally you get a value in an object by its key, but if you want to iterate all of the keys you can use this method. Call it until it returns false.</p>
<p>This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an object, use <a class="el" href="class_json_parser.html#a39d613e94d0d6beafe908159f86bc067" title="Given an object token in container, gets the token value with the specified key name. ">getValueTokenByKey()</a> instead. </p>

</div>
</div>
<a id="a946929ab0c54eed7e7c8697e9304d553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946929ab0c54eed7e7c8697e9304d553">&#9670;&nbsp;</a></span>getKeyValueTokenByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getKeyValueTokenByIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a JSON object in container, gets the key/value pair specified by index. Internal use only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The array token to look in.</td></tr>
    <tr><td class="paramname">key</td><td>Filled in with the key token for nth key value pair.</td></tr>
    <tr><td class="paramname">value</td><td>Filled in with the value token for then nth key value pair.</td></tr>
    <tr><td class="paramname">index</td><td>The index to retrieve (0 = first, 1 = second, ...).</td></tr>
  </table>
  </dd>
</dl>
<p>This is a low-level function; you will typically use <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a> or <a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06" title="Given an object token in container, gets the value with the specified key name. ">getValueByKey()</a> instead. </p>

</div>
</div>
<a id="a91ffa7e1c4d2fbc2524533d65c31b605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ffa7e1c4d2fbc2524533d65c31b605">&#9670;&nbsp;</a></span>getOuterArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> * JsonParser::getOuterArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the outer JSON array token. </p>
<p>Sometimes the JSON will contain an array of values (or objects) instead of starting with an object. This gets the outermost array.</p>
<p>A token (<a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html" title="JSON token description. ">JsonParserGeneratorRK::jsmntok_t</a>) identifies a particular piece of data in the JSON data, such as an object, array, or element within an object or array, such as a string, integer, boolean, etc.. </p>

</div>
</div>
<a id="a4718893bc6350e129a9acbf6cb5a47ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4718893bc6350e129a9acbf6cb5a47ad">&#9670;&nbsp;</a></span>getOuterKeyValueByIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getOuterKeyValueByIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the key/value pair of the outer object by index (0 = first, 1 = second, ...) </p>
<p>Normally you get a value in an object by its key, but if you want to iterate all of the keys you can use this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>0 = first, 1 = second, ...</td></tr>
    <tr><td class="paramname">key</td><td>Filled in with the name of the key</td></tr>
    <tr><td class="paramname">result</td><td>Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a>, or (char *, size_t&amp;).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the call succeeded or false if it failed.</dd></dl>
<p>This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an object, use <a class="el" href="class_json_parser.html#a39d613e94d0d6beafe908159f86bc067" title="Given an object token in container, gets the token value with the specified key name. ">getValueTokenByKey()</a> instead. </p>

</div>
</div>
<a id="a4e694318a7c823d4cca3a5be49907df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e694318a7c823d4cca3a5be49907df7">&#9670;&nbsp;</a></span>getOuterObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> * JsonParser::getOuterObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the outer JSON object token. </p>
<p>Typically JSON will contain an object that contains values and possibly other objects. This method gets the token for the outer object.</p>
<p>A token (<a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html" title="JSON token description. ">JsonParserGeneratorRK::jsmntok_t</a>) identifies a particular piece of data in the JSON data, such as an object, array, or element within an object or array, such as a string, integer, boolean, etc.. </p>

</div>
</div>
<a id="a3c28b01c0e1fc3c7677e07e1739ea288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c28b01c0e1fc3c7677e07e1739ea288">&#9670;&nbsp;</a></span>getOuterToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> * JsonParser::getOuterToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the outer JSON object or array token. </p>
<p>A token (<a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html" title="JSON token description. ">JsonParserGeneratorRK::jsmntok_t</a>) identifies a particular piece of data in the JSON data, such as an object, array, or element within an object or array, such as a string, integer, boolean, etc.. </p>

</div>
</div>
<a id="a38858994342cd2735b716b117bf8afdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38858994342cd2735b716b117bf8afdf">&#9670;&nbsp;</a></span>getOuterValueByKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getOuterValueByKey </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value with the specified key name out of the outer object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the key to retrieve</td></tr>
    <tr><td class="paramname">result</td><td>The returned data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the data was retrieved successfully, false if not (key not present or incompatible data type).</dd></dl>
<p>The outer object must be a JSON object, not an array.</p>
<p>This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an object, use <a class="el" href="class_json_parser.html#a39d613e94d0d6beafe908159f86bc067" title="Given an object token in container, gets the token value with the specified key name. ">getValueTokenByKey()</a> instead. </p>

</div>
</div>
<a id="a588d9c4fcfe9179db67ca42f5ba5229d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588d9c4fcfe9179db67ca42f5ba5229d">&#9670;&nbsp;</a></span>getTokenByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> * JsonParser::getTokenByIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>desiredIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a containing object, finds the nth token in the object. Internal use only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The array token to look in.</td></tr>
    <tr><td class="paramname">desiredIndex</td><td>The index to retrieve (0 = first, 1 = second, ...).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The token</dd></dl>
<p>This is used internally. It should not be used to get the nth array value, use getValueTokenByIndex instead. </p>

</div>
</div>
<a id="a334ccfff663a5d3155a799049896d55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334ccfff663a5d3155a799049896d55c">&#9670;&nbsp;</a></span>getTokenJsonString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenJsonString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a token (object, array, string, or primitive) back into JSON in a Wiring <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to convert back to a string</td></tr>
    <tr><td class="paramname">result</td><td>Filled in with the string. Any previous contents in the string are cleared first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af235693afede52de81794e3773e5cff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af235693afede52de81794e3773e5cff4">&#9670;&nbsp;</a></span>getTokenJsonString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenJsonString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>strLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a token (object, array, string, or primitive) back into JSON in a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to convert back to a string</td></tr>
    <tr><td class="paramname">str</td><td>The buffer to be written to</td></tr>
    <tr><td class="paramname">strLen</td><td>The length of the buffer on entry, set to the number of bytes written on exit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6d9fc64d49d057dd2b7b3ea63a7d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6d9fc64d49d057dd2b7b3ea63a7d8c">&#9670;&nbsp;</a></span>getTokenJsonString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenJsonString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_json_parser_string.html">JsonParserString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a token as a JSON string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to convert back to a string</td></tr>
    <tr><td class="paramname">str</td><td>The <a class="el" href="class_json_parser_string.html" title="Class used internally for writing to strings. ">JsonParserString</a> object to write to</td></tr>
  </table>
  </dd>
</dl>
<p>This overload is typically used internally, normally you'd use the version that takes a <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a>&amp; or char *, size_t. </p>

</div>
</div>
<a id="a5f9e5c2453307a99a54fcf26fbd68dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9e5c2453307a99a54fcf26fbd68dd4">&#9670;&nbsp;</a></span>getTokenValue() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a bool (boolean) value. </p>
<p>Normally you'd use <a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06" title="Given an object token in container, gets the value with the specified key name. ">getValueByKey()</a>, <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a> or <a class="el" href="class_json_parser.html#af1f4a3a65b5cc9cd19b129c410aa78e0" title="This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values...">getValueByColRow()</a> which will automatically use this when the result parameter is a bool variable. </p>

</div>
</div>
<a id="a875e5b4b01c9cd597e09b13e59fe6252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875e5b4b01c9cd597e09b13e59fe6252">&#9670;&nbsp;</a></span>getTokenValue() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an integer value. </p>
<p>Normally you'd use <a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06" title="Given an object token in container, gets the value with the specified key name. ">getValueByKey()</a>, <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a> or <a class="el" href="class_json_parser.html#af1f4a3a65b5cc9cd19b129c410aa78e0" title="This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values...">getValueByColRow()</a> which will automatically use this when the result parameter is an int variable. </p>

</div>
</div>
<a id="ad6289b63a2281dc516e4a81aa3660ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6289b63a2281dc516e4a81aa3660ac7">&#9670;&nbsp;</a></span>getTokenValue() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an unsigned long value. </p>
<p>Normally you'd use <a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06" title="Given an object token in container, gets the value with the specified key name. ">getValueByKey()</a>, <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a> or <a class="el" href="class_json_parser.html#af1f4a3a65b5cc9cd19b129c410aa78e0" title="This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values...">getValueByColRow()</a> which will automatically use this when the result parameter is an unsigned long variable. </p>

</div>
</div>
<a id="a37a6ad66b9697ceb6b789b4c9abaa3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a6ad66b9697ceb6b789b4c9abaa3ab">&#9670;&nbsp;</a></span>getTokenValue() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a float (single precision floating point) value. </p>
<p>Normally you'd use <a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06" title="Given an object token in container, gets the value with the specified key name. ">getValueByKey()</a>, <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a> or <a class="el" href="class_json_parser.html#af1f4a3a65b5cc9cd19b129c410aa78e0" title="This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values...">getValueByColRow()</a> which will automatically use this when the result parameter is a float variable. </p>

</div>
</div>
<a id="af378b1400c3f091ae6ba67dc588ca863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af378b1400c3f091ae6ba67dc588ca863">&#9670;&nbsp;</a></span>getTokenValue() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a double (double precision floating point) value. </p>
<p>Normally you'd use <a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06" title="Given an object token in container, gets the value with the specified key name. ">getValueByKey()</a>, <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a> or <a class="el" href="class_json_parser.html#af1f4a3a65b5cc9cd19b129c410aa78e0" title="This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values...">getValueByColRow()</a> which will automatically use this when the result parameter is a double variable. </p>

</div>
</div>
<a id="a44cff567586e80ba63d39324e5929672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cff567586e80ba63d39324e5929672">&#9670;&nbsp;</a></span>getTokenValue() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a> value into a Wiring <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a> object. </p>
<p>This will automatically decode Unicode character escapes in the data and the returned <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a> will contain UTF-8.</p>
<p>Normally you'd use <a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06" title="Given an object token in container, gets the value with the specified key name. ">getValueByKey()</a>, <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a> or <a class="el" href="class_json_parser.html#af1f4a3a65b5cc9cd19b129c410aa78e0" title="This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values...">getValueByColRow()</a> which will automatically use this when the result parameter is a <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a> variable. </p>

</div>
</div>
<a id="aa5c0b33d4ddeae1e0d605e166a2a772c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c0b33d4ddeae1e0d605e166a2a772c">&#9670;&nbsp;</a></span>getTokenValue() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>strLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string as a c-string into the specified buffer. </p>
<p>If the token specifies too large of a string it will be truncated. This will automatically decode Unicode character escapes in the data and the returned string will contain UTF-8. </p>

</div>
</div>
<a id="a6942f718b6b73d2ff1611f55aec8569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6942f718b6b73d2ff1611f55aec8569c">&#9670;&nbsp;</a></span>getTokenValue() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getTokenValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_json_parser_string.html">JsonParserString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string as a <a class="el" href="class_json_parser_string.html" title="Class used internally for writing to strings. ">JsonParserString</a> object. </p>
<p>This is used internally by <a class="el" href="class_json_parser.html#a5f9e5c2453307a99a54fcf26fbd68dd4" title="Gets a bool (boolean) value. ">getTokenValue()</a> overloads that take a <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a> or buffer and length; you will normally not need to use this directly.</p>
<p>This will automatically decode Unicode character escapes in the data and the returned string will contain UTF-8. </p>

</div>
</div>
<a id="af1f4a3a65b5cc9cd19b129c410aa78e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f4a3a65b5cc9cd19b129c410aa78e0">&#9670;&nbsp;</a></span>getValueByColRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getValueByColRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>arrayContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayContainer</td><td>A token for an array containing another array</td></tr>
    <tr><td class="paramname">col</td><td>The column (outer array index, 0 = first column, 1 = second column, ...)</td></tr>
    <tr><td class="paramname">row</td><td>The row (inner array index, 0 = first row, 1 = second row, ...)</td></tr>
    <tr><td class="paramname">result</td><td>Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a>, or (char *, size_t&amp;).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the call succeeded or false if it failed. You can call this repeatedly until it returns false to iterate the array.</dd></dl>
<p>This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within a two-dimensional array, use <a class="el" href="class_json_parser.html#a4fc494206dd45eba5959ffc2df444a21" title="This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values...">getValueTokenByColRow()</a> instead. </p>

</div>
</div>
<a id="a53bd8a6ebb0d9b246b876653e792368f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bd8a6ebb0d9b246b876653e792368f">&#9670;&nbsp;</a></span>getValueByIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getValueByIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>arrayContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an array token in arrayContainer, gets the value with the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayContainer</td><td>A token for an array</td></tr>
    <tr><td class="paramname">index</td><td>The index in the array. 0 = first item, 1 = second item, ...</td></tr>
    <tr><td class="paramname">result</td><td>Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a>, or (char *, size_t&amp;).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the call succeeded or false if it failed. You can call this repeatedly until it returns false to iterate the array.</dd></dl>
<p>This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an array, use <a class="el" href="class_json_parser.html#a680846b3e3e3e1d40c27bbb71e080048" title="Given an array token in container, gets the token value with the specified index. ...">getValueTokenByIndex()</a> instead. </p>

</div>
</div>
<a id="a13abcdcb2341f65ac358bb4d81007d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13abcdcb2341f65ac358bb4d81007d06">&#9670;&nbsp;</a></span>getValueByKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getValueByKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an object token in container, gets the value with the specified key name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The token for the object to obtain the data from.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the key to retrieve</td></tr>
    <tr><td class="paramname">result</td><td>The returned data. The value can be of type: bool, int, unsigned long, float, double, <a class="el" href="class_string.html" title="Wiring String: A class to hold and manipulate a dynamically allocated string. ">String</a>, or (char *, size_t&amp;).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the data was retrieved successfully, false if not (key not present or incompatible data type).</dd></dl>
<p>This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an object, use <a class="el" href="class_json_parser.html#a39d613e94d0d6beafe908159f86bc067" title="Given an object token in container, gets the token value with the specified key name. ">getValueTokenByKey()</a> instead. </p>

</div>
</div>
<a id="a4fc494206dd45eba5959ffc2df444a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc494206dd45eba5959ffc2df444a21">&#9670;&nbsp;</a></span>getValueTokenByColRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getValueTokenByColRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>A token for an array containing another array</td></tr>
    <tr><td class="paramname">col</td><td>The column (outer array index, 0 = first column, 1 = second column, ...)</td></tr>
    <tr><td class="paramname">row</td><td>The row (inner array index, 0 = first row, 1 = second row, ...)</td></tr>
    <tr><td class="paramname">value</td><td>Filled in with the token for the value for key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the index row and column are valid or false if either is out of range.</dd></dl>
<p>This can be used for 2-dimensional arrays whose values are arrays or objects, to get the token for the container. It can also be used for values, but normally you'd use <a class="el" href="class_json_parser.html#af1f4a3a65b5cc9cd19b129c410aa78e0" title="This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values...">getValueByColRow()</a> instead, which is generally more convenient. </p>

</div>
</div>
<a id="a680846b3e3e3e1d40c27bbb71e080048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680846b3e3e3e1d40c27bbb71e080048">&#9670;&nbsp;</a></span>getValueTokenByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getValueTokenByIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>desiredIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array token in container, gets the token value with the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The array token to look in.</td></tr>
    <tr><td class="paramname">desiredIndex</td><td>The index to retrieve (0 = first, 1 = second, ...).</td></tr>
    <tr><td class="paramname">value</td><td>Filled in with the token for the value for key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the index is valid or false if the index exceeds the size of the array.</dd></dl>
<p>This can be used for arrays whose values are arrays or objects, to get the token for the container. It can also be used for values, but normally you'd use <a class="el" href="class_json_parser.html#a53bd8a6ebb0d9b246b876653e792368f" title="Given an array token in arrayContainer, gets the value with the specified index. ">getValueByIndex()</a> instead, which is generally more convenient. </p>

</div>
</div>
<a id="a39d613e94d0d6beafe908159f86bc067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d613e94d0d6beafe908159f86bc067">&#9670;&nbsp;</a></span>getValueTokenByKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::getValueTokenByKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an object token in container, gets the token value with the specified key name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The object token to look in.</td></tr>
    <tr><td class="paramname">key</td><td>The key to look for.</td></tr>
    <tr><td class="paramname">value</td><td>Filled in with the token for the value for key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key is found or false if not.</dd></dl>
<p>This can be used for objects whose keys are arrays or objects, to get the token for the container. It can also be used for values, but normally you'd use <a class="el" href="class_json_parser.html#a13abcdcb2341f65ac358bb4d81007d06" title="Given an object token in container, gets the value with the specified key name. ">getValueByKey()</a> instead, which is generally more convenient. </p>

</div>
</div>
<a id="ad528213e8600cbad4d85910b62fc033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad528213e8600cbad4d85910b62fc033a">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::parse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the data you have added using <a class="el" href="class_json_buffer.html#a760cb5be42ed2d2ca9306b1109e76af3" title="Add a string to the end of the buffer. ">addData()</a> or <a class="el" href="class_json_buffer.html#a61bf30ac6e1bd460f1e809d02a7d5ba4" title="Add a c-string to the end of the buffer. ">addString()</a>. </p>
<p>When parsing data split into multiple chunks as a webhook response you can call <a class="el" href="class_json_buffer.html#a61bf30ac6e1bd460f1e809d02a7d5ba4" title="Add a c-string to the end of the buffer. ">addString()</a> in your webhook subscription handler and call parse after each chunk. Only on the last chunk will parse return true, and you'll know the entire reponse has been received. </p>

</div>
</div>
<a id="a182ab93b3639f0a99f37f9101eb48361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182ab93b3639f0a99f37f9101eb48361">&#9670;&nbsp;</a></span>skipObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JsonParser::skipObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_json_parser_generator_r_k_1_1jsmntok__t.html">JsonParserGeneratorRK::jsmntok_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used internally to skip over the token in obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The array token to look in.</td></tr>
    <tr><td class="paramname">obj</td><td>Object within the token, updated to the next object if true is returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there was a next object, false if not.</dd></dl>
<p>For simple primitives and strings, this is equivalent to obj++. For objects and arrays, however, this skips over the entire object or array, including any nested objects within them. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_json_parser_generator_r_k_8h_source.html">JsonParserGeneratorRK.h</a></li>
<li>src/JsonParserGeneratorRK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
